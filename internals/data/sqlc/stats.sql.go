// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: stats.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createNFLStat = `-- name: CreateNFLStat :exec
INSERT INTO nfl_stats (
  game_id, player_id, team_id, category, stat_type, stat_value
) VALUES (
  ?, ?, ?, ?, ?, ?
)
`

type CreateNFLStatParams struct {
	GameID    int64   `json:"game_id"`
	PlayerID  string  `json:"player_id"`
	TeamID    string  `json:"team_id"`
	Category  string  `json:"category"`
	StatType  string  `json:"stat_type"`
	StatValue float64 `json:"stat_value"`
}

func (q *Queries) CreateNFLStat(ctx context.Context, arg CreateNFLStatParams) error {
	_, err := q.exec(ctx, q.createNFLStatStmt, createNFLStat,
		arg.GameID,
		arg.PlayerID,
		arg.TeamID,
		arg.Category,
		arg.StatType,
		arg.StatValue,
	)
	return err
}

const deleteNFLStat = `-- name: DeleteNFLStat :exec
DELETE FROM nfl_stats
WHERE stat_id = ?
`

func (q *Queries) DeleteNFLStat(ctx context.Context, statID int64) error {
	_, err := q.exec(ctx, q.deleteNFLStatStmt, deleteNFLStat, statID)
	return err
}

const getGamesBySeason = `-- name: GetGamesBySeason :many
SELECT event_id, date, name, short_name, season, week, away_team, home_team FROM nfl_games
WHERE season = ?
ORDER BY week, date
`

func (q *Queries) GetGamesBySeason(ctx context.Context, season int64) ([]*NflGame, error) {
	rows, err := q.query(ctx, q.getGamesBySeasonStmt, getGamesBySeason, season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NflGame{}
	for rows.Next() {
		var i NflGame
		if err := rows.Scan(
			&i.EventID,
			&i.Date,
			&i.Name,
			&i.ShortName,
			&i.Season,
			&i.Week,
			&i.AwayTeam,
			&i.HomeTeam,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerSeasonalStatsByType = `-- name: GetPlayerSeasonalStatsByType :many
SELECT 
  g.season,
  SUM(s.stat_value) as total_value
FROM 
  nfl_stats s
JOIN 
  nfl_games g ON s.game_id = g.event_id
JOIN
  nfl_player_seasons ps ON s.player_id = ps.player_id AND g.season = ps.season_year
WHERE 
  s.player_id = ? AND s.stat_type = ?
GROUP BY 
  g.season
ORDER BY 
  g.season DESC
`

type GetPlayerSeasonalStatsByTypeParams struct {
	PlayerID string `json:"player_id"`
	StatType string `json:"stat_type"`
}

type GetPlayerSeasonalStatsByTypeRow struct {
	Season     int64           `json:"season"`
	TotalValue sql.NullFloat64 `json:"total_value"`
}

// Get seasonal stats for a player across multiple seasons (for comparison)
func (q *Queries) GetPlayerSeasonalStatsByType(ctx context.Context, arg GetPlayerSeasonalStatsByTypeParams) ([]*GetPlayerSeasonalStatsByTypeRow, error) {
	rows, err := q.query(ctx, q.getPlayerSeasonalStatsByTypeStmt, getPlayerSeasonalStatsByType, arg.PlayerID, arg.StatType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerSeasonalStatsByTypeRow{}
	for rows.Next() {
		var i GetPlayerSeasonalStatsByTypeRow
		if err := rows.Scan(&i.Season, &i.TotalValue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatAverage = `-- name: GetPlayerStatAverage :one
SELECT 
  AVG(stat_value) as avg_value
FROM 
  nfl_stats
WHERE 
  player_id = ? AND stat_type = ?
`

type GetPlayerStatAverageParams struct {
	PlayerID string `json:"player_id"`
	StatType string `json:"stat_type"`
}

// Get the average of a specific stat type for a player
func (q *Queries) GetPlayerStatAverage(ctx context.Context, arg GetPlayerStatAverageParams) (sql.NullFloat64, error) {
	row := q.queryRow(ctx, q.getPlayerStatAverageStmt, getPlayerStatAverage, arg.PlayerID, arg.StatType)
	var avg_value sql.NullFloat64
	err := row.Scan(&avg_value)
	return avg_value, err
}

const getPlayerStatsByCurrentTeam = `-- name: GetPlayerStatsByCurrentTeam :many
SELECT 
  p.player_id,
  p.full_name,
  p.position,
  s.stat_type,
  SUM(s.stat_value) as total_value
FROM 
  nfl_stats s
JOIN 
  nfl_players p ON s.player_id = p.player_id
JOIN 
  nfl_games g ON s.game_id = g.event_id
WHERE 
  p.team_id = ? AND g.season = ?
GROUP BY 
  p.player_id, p.full_name, p.position, s.stat_type
ORDER BY 
  p.position, s.stat_type, total_value DESC
`

type GetPlayerStatsByCurrentTeamParams struct {
	TeamID sql.NullString `json:"team_id"`
	Season int64          `json:"season"`
}

type GetPlayerStatsByCurrentTeamRow struct {
	PlayerID   string          `json:"player_id"`
	FullName   string          `json:"full_name"`
	Position   string          `json:"position"`
	StatType   string          `json:"stat_type"`
	TotalValue sql.NullFloat64 `json:"total_value"`
}

// Get stats for players currently on a specific team
func (q *Queries) GetPlayerStatsByCurrentTeam(ctx context.Context, arg GetPlayerStatsByCurrentTeamParams) ([]*GetPlayerStatsByCurrentTeamRow, error) {
	rows, err := q.query(ctx, q.getPlayerStatsByCurrentTeamStmt, getPlayerStatsByCurrentTeam, arg.TeamID, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerStatsByCurrentTeamRow{}
	for rows.Next() {
		var i GetPlayerStatsByCurrentTeamRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.FullName,
			&i.Position,
			&i.StatType,
			&i.TotalValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsByGame = `-- name: GetPlayerStatsByGame :many
SELECT 
  s.category,
  s.stat_type,
  s.stat_value
FROM 
  nfl_stats s
WHERE 
  s.player_id = ? AND s.game_id = ?
ORDER BY 
  s.category, s.stat_type
`

type GetPlayerStatsByGameParams struct {
	PlayerID string `json:"player_id"`
	GameID   int64  `json:"game_id"`
}

type GetPlayerStatsByGameRow struct {
	Category  string  `json:"category"`
	StatType  string  `json:"stat_type"`
	StatValue float64 `json:"stat_value"`
}

// Get all stats for a player in a specific game
func (q *Queries) GetPlayerStatsByGame(ctx context.Context, arg GetPlayerStatsByGameParams) ([]*GetPlayerStatsByGameRow, error) {
	rows, err := q.query(ctx, q.getPlayerStatsByGameStmt, getPlayerStatsByGame, arg.PlayerID, arg.GameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerStatsByGameRow{}
	for rows.Next() {
		var i GetPlayerStatsByGameRow
		if err := rows.Scan(&i.Category, &i.StatType, &i.StatValue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsBySeasonTeam = `-- name: GetPlayerStatsBySeasonTeam :many
SELECT 
  p.player_id,
  p.full_name,
  p.position,
  s.stat_type,
  SUM(s.stat_value) as total_value
FROM 
  nfl_stats s
JOIN 
  nfl_players p ON s.player_id = p.player_id
JOIN 
  nfl_player_seasons ps ON s.player_id = ps.player_id
JOIN 
  nfl_games g ON s.game_id = g.event_id
WHERE 
  ps.team_id = ? AND ps.season_year = ? AND g.season = ps.season_year
GROUP BY 
  p.player_id, p.full_name, p.position, s.stat_type
ORDER BY 
  p.position, s.stat_type, total_value DESC
`

type GetPlayerStatsBySeasonTeamParams struct {
	TeamID     sql.NullString `json:"team_id"`
	SeasonYear int64          `json:"season_year"`
}

type GetPlayerStatsBySeasonTeamRow struct {
	PlayerID   string          `json:"player_id"`
	FullName   string          `json:"full_name"`
	Position   string          `json:"position"`
	StatType   string          `json:"stat_type"`
	TotalValue sql.NullFloat64 `json:"total_value"`
}

// Get stats for players on a specific team in a specific season
func (q *Queries) GetPlayerStatsBySeasonTeam(ctx context.Context, arg GetPlayerStatsBySeasonTeamParams) ([]*GetPlayerStatsBySeasonTeamRow, error) {
	rows, err := q.query(ctx, q.getPlayerStatsBySeasonTeamStmt, getPlayerStatsBySeasonTeam, arg.TeamID, arg.SeasonYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerStatsBySeasonTeamRow{}
	for rows.Next() {
		var i GetPlayerStatsBySeasonTeamRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.FullName,
			&i.Position,
			&i.StatType,
			&i.TotalValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsByWeek = `-- name: GetPlayerStatsByWeek :many
SELECT 
  s.category,
  s.stat_type,
  s.stat_value
FROM 
  nfl_stats s
JOIN 
  nfl_games g ON s.game_id = g.event_id
WHERE 
  s.player_id = ? AND g.season = ? AND g.week = ?
ORDER BY 
  s.category, s.stat_type
`

type GetPlayerStatsByWeekParams struct {
	PlayerID string `json:"player_id"`
	Season   int64  `json:"season"`
	Week     int64  `json:"week"`
}

type GetPlayerStatsByWeekRow struct {
	Category  string  `json:"category"`
	StatType  string  `json:"stat_type"`
	StatValue float64 `json:"stat_value"`
}

// Get a player's stats for a specific week in a season
func (q *Queries) GetPlayerStatsByWeek(ctx context.Context, arg GetPlayerStatsByWeekParams) ([]*GetPlayerStatsByWeekRow, error) {
	rows, err := q.query(ctx, q.getPlayerStatsByWeekStmt, getPlayerStatsByWeek, arg.PlayerID, arg.Season, arg.Week)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerStatsByWeekRow{}
	for rows.Next() {
		var i GetPlayerStatsByWeekRow
		if err := rows.Scan(&i.Category, &i.StatType, &i.StatValue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerTotalStatByType = `-- name: GetPlayerTotalStatByType :one

SELECT 
  SUM(stat_value) as total_value
FROM 
  nfl_stats
WHERE 
  player_id = ? AND stat_type = ?
`

type GetPlayerTotalStatByTypeParams struct {
	PlayerID string `json:"player_id"`
	StatType string `json:"stat_type"`
}

// CORE AGGREGATION FUNCTIONS
// Get the total of a specific stat type for a player
func (q *Queries) GetPlayerTotalStatByType(ctx context.Context, arg GetPlayerTotalStatByTypeParams) (sql.NullFloat64, error) {
	row := q.queryRow(ctx, q.getPlayerTotalStatByTypeStmt, getPlayerTotalStatByType, arg.PlayerID, arg.StatType)
	var total_value sql.NullFloat64
	err := row.Scan(&total_value)
	return total_value, err
}

const getPlayerTotalStatByTypeForSeason = `-- name: GetPlayerTotalStatByTypeForSeason :one
SELECT 
  SUM(s.stat_value) as total_value
FROM 
  nfl_stats s
JOIN 
  nfl_games g ON s.game_id = g.event_id
WHERE 
  s.player_id = ? AND s.stat_type = ? AND g.season = ?
`

type GetPlayerTotalStatByTypeForSeasonParams struct {
	PlayerID string `json:"player_id"`
	StatType string `json:"stat_type"`
	Season   int64  `json:"season"`
}

// Get the total of a specific stat type for a player in a specific season
func (q *Queries) GetPlayerTotalStatByTypeForSeason(ctx context.Context, arg GetPlayerTotalStatByTypeForSeasonParams) (sql.NullFloat64, error) {
	row := q.queryRow(ctx, q.getPlayerTotalStatByTypeForSeasonStmt, getPlayerTotalStatByTypeForSeason, arg.PlayerID, arg.StatType, arg.Season)
	var total_value sql.NullFloat64
	err := row.Scan(&total_value)
	return total_value, err
}

const getPlayerTotalStatsByPosition = `-- name: GetPlayerTotalStatsByPosition :many
SELECT 
  p.player_id,
  p.full_name,
  s.stat_type,
  SUM(s.stat_value) as total_value
FROM 
  nfl_stats s
JOIN 
  nfl_players p ON s.player_id = p.player_id
JOIN 
  nfl_games g ON s.game_id = g.event_id
WHERE 
  p.position = ? AND g.season = ?
GROUP BY 
  p.player_id, p.full_name, s.stat_type
ORDER BY 
  s.stat_type, total_value DESC
`

type GetPlayerTotalStatsByPositionParams struct {
	Position string `json:"position"`
	Season   int64  `json:"season"`
}

type GetPlayerTotalStatsByPositionRow struct {
	PlayerID   string          `json:"player_id"`
	FullName   string          `json:"full_name"`
	StatType   string          `json:"stat_type"`
	TotalValue sql.NullFloat64 `json:"total_value"`
}

// Get total stats for all players of a specific position in a season
func (q *Queries) GetPlayerTotalStatsByPosition(ctx context.Context, arg GetPlayerTotalStatsByPositionParams) ([]*GetPlayerTotalStatsByPositionRow, error) {
	rows, err := q.query(ctx, q.getPlayerTotalStatsByPositionStmt, getPlayerTotalStatsByPosition, arg.Position, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerTotalStatsByPositionRow{}
	for rows.Next() {
		var i GetPlayerTotalStatsByPositionRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.FullName,
			&i.StatType,
			&i.TotalValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerTotalStatsBySeason = `-- name: GetPlayerTotalStatsBySeason :many
SELECT 
  s.stat_type,
  SUM(s.stat_value) as total_value
FROM 
  nfl_stats s
JOIN 
  nfl_games g ON s.game_id = g.event_id
WHERE 
  s.player_id = ? AND g.season = ?
GROUP BY 
  s.stat_type
ORDER BY 
  s.stat_type
`

type GetPlayerTotalStatsBySeasonParams struct {
	PlayerID string `json:"player_id"`
	Season   int64  `json:"season"`
}

type GetPlayerTotalStatsBySeasonRow struct {
	StatType   string          `json:"stat_type"`
	TotalValue sql.NullFloat64 `json:"total_value"`
}

// Get a player's total stats for each stat type in a season
func (q *Queries) GetPlayerTotalStatsBySeason(ctx context.Context, arg GetPlayerTotalStatsBySeasonParams) ([]*GetPlayerTotalStatsBySeasonRow, error) {
	rows, err := q.query(ctx, q.getPlayerTotalStatsBySeasonStmt, getPlayerTotalStatsBySeason, arg.PlayerID, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerTotalStatsBySeasonRow{}
	for rows.Next() {
		var i GetPlayerTotalStatsBySeasonRow
		if err := rows.Scan(&i.StatType, &i.TotalValue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerWeeklyStatByType = `-- name: GetPlayerWeeklyStatByType :many
SELECT 
  g.week,
  COALESCE(SUM(s.stat_value), 0) as stat_value
FROM 
  nfl_games g
LEFT JOIN 
  nfl_stats s ON g.event_id = s.game_id AND s.player_id = ? AND s.stat_type = ?
WHERE 
  g.season = ?
GROUP BY 
  g.week
ORDER BY 
  g.week
`

type GetPlayerWeeklyStatByTypeParams struct {
	PlayerID string `json:"player_id"`
	StatType string `json:"stat_type"`
	Season   int64  `json:"season"`
}

type GetPlayerWeeklyStatByTypeRow struct {
	Week      int64       `json:"week"`
	StatValue interface{} `json:"stat_value"`
}

// Get weekly stats of a specific type for a player in a season
func (q *Queries) GetPlayerWeeklyStatByType(ctx context.Context, arg GetPlayerWeeklyStatByTypeParams) ([]*GetPlayerWeeklyStatByTypeRow, error) {
	rows, err := q.query(ctx, q.getPlayerWeeklyStatByTypeStmt, getPlayerWeeklyStatByType, arg.PlayerID, arg.StatType, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerWeeklyStatByTypeRow{}
	for rows.Next() {
		var i GetPlayerWeeklyStatByTypeRow
		if err := rows.Scan(&i.Week, &i.StatValue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByCategory = `-- name: GetStatsByCategory :many
SELECT stat_id, game_id, player_id, team_id, category, stat_type, stat_value FROM nfl_stats
WHERE category = ?
ORDER BY game_id, player_id, stat_type
`

func (q *Queries) GetStatsByCategory(ctx context.Context, category string) ([]*NflStat, error) {
	rows, err := q.query(ctx, q.getStatsByCategoryStmt, getStatsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NflStat{}
	for rows.Next() {
		var i NflStat
		if err := rows.Scan(
			&i.StatID,
			&i.GameID,
			&i.PlayerID,
			&i.TeamID,
			&i.Category,
			&i.StatType,
			&i.StatValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByGame = `-- name: GetStatsByGame :many
SELECT stat_id, game_id, player_id, team_id, category, stat_type, stat_value FROM nfl_stats
WHERE game_id = ?
ORDER BY player_id, category, stat_type
`

func (q *Queries) GetStatsByGame(ctx context.Context, gameID int64) ([]*NflStat, error) {
	rows, err := q.query(ctx, q.getStatsByGameStmt, getStatsByGame, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NflStat{}
	for rows.Next() {
		var i NflStat
		if err := rows.Scan(
			&i.StatID,
			&i.GameID,
			&i.PlayerID,
			&i.TeamID,
			&i.Category,
			&i.StatType,
			&i.StatValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByGameAndPlayer = `-- name: GetStatsByGameAndPlayer :many
SELECT stat_id, game_id, player_id, team_id, category, stat_type, stat_value FROM nfl_stats
WHERE game_id = ? AND player_id = ?
ORDER BY category, stat_type
`

type GetStatsByGameAndPlayerParams struct {
	GameID   int64  `json:"game_id"`
	PlayerID string `json:"player_id"`
}

func (q *Queries) GetStatsByGameAndPlayer(ctx context.Context, arg GetStatsByGameAndPlayerParams) ([]*NflStat, error) {
	rows, err := q.query(ctx, q.getStatsByGameAndPlayerStmt, getStatsByGameAndPlayer, arg.GameID, arg.PlayerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NflStat{}
	for rows.Next() {
		var i NflStat
		if err := rows.Scan(
			&i.StatID,
			&i.GameID,
			&i.PlayerID,
			&i.TeamID,
			&i.Category,
			&i.StatType,
			&i.StatValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByPlayer = `-- name: GetStatsByPlayer :many
SELECT stat_id, game_id, player_id, team_id, category, stat_type, stat_value FROM nfl_stats
WHERE player_id = ?
ORDER BY game_id, category, stat_type
`

func (q *Queries) GetStatsByPlayer(ctx context.Context, playerID string) ([]*NflStat, error) {
	rows, err := q.query(ctx, q.getStatsByPlayerStmt, getStatsByPlayer, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NflStat{}
	for rows.Next() {
		var i NflStat
		if err := rows.Scan(
			&i.StatID,
			&i.GameID,
			&i.PlayerID,
			&i.TeamID,
			&i.Category,
			&i.StatType,
			&i.StatValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByStatType = `-- name: GetStatsByStatType :many
SELECT stat_id, game_id, player_id, team_id, category, stat_type, stat_value FROM nfl_stats
WHERE stat_type = ?
ORDER BY game_id, player_id, category
`

func (q *Queries) GetStatsByStatType(ctx context.Context, statType string) ([]*NflStat, error) {
	rows, err := q.query(ctx, q.getStatsByStatTypeStmt, getStatsByStatType, statType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NflStat{}
	for rows.Next() {
		var i NflStat
		if err := rows.Scan(
			&i.StatID,
			&i.GameID,
			&i.PlayerID,
			&i.TeamID,
			&i.Category,
			&i.StatType,
			&i.StatValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByTeam = `-- name: GetStatsByTeam :many
SELECT stat_id, game_id, player_id, team_id, category, stat_type, stat_value FROM nfl_stats
WHERE team_id = ?
ORDER BY game_id, player_id, category, stat_type
`

func (q *Queries) GetStatsByTeam(ctx context.Context, teamID string) ([]*NflStat, error) {
	rows, err := q.query(ctx, q.getStatsByTeamStmt, getStatsByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NflStat{}
	for rows.Next() {
		var i NflStat
		if err := rows.Scan(
			&i.StatID,
			&i.GameID,
			&i.PlayerID,
			&i.TeamID,
			&i.Category,
			&i.StatType,
			&i.StatValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamStatsBySeason = `-- name: GetTeamStatsBySeason :many
SELECT 
  t.team_id,
  t.display_name,
  s.stat_type,
  SUM(s.stat_value) as total_value,
  AVG(s.stat_value) as avg_value_per_game
FROM 
  nfl_stats s
JOIN 
  nfl_teams t ON s.team_id = t.team_id
JOIN 
  nfl_games g ON s.game_id = g.event_id
WHERE 
  s.category = ? AND g.season = ?
GROUP BY 
  t.team_id, t.display_name, s.stat_type
ORDER BY 
  s.stat_type, total_value DESC
`

type GetTeamStatsBySeasonParams struct {
	Category string `json:"category"`
	Season   int64  `json:"season"`
}

type GetTeamStatsBySeasonRow struct {
	TeamID          string          `json:"team_id"`
	DisplayName     string          `json:"display_name"`
	StatType        string          `json:"stat_type"`
	TotalValue      sql.NullFloat64 `json:"total_value"`
	AvgValuePerGame sql.NullFloat64 `json:"avg_value_per_game"`
}

// Get team-level stats for a specific season
func (q *Queries) GetTeamStatsBySeason(ctx context.Context, arg GetTeamStatsBySeasonParams) ([]*GetTeamStatsBySeasonRow, error) {
	rows, err := q.query(ctx, q.getTeamStatsBySeasonStmt, getTeamStatsBySeason, arg.Category, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTeamStatsBySeasonRow{}
	for rows.Next() {
		var i GetTeamStatsBySeasonRow
		if err := rows.Scan(
			&i.TeamID,
			&i.DisplayName,
			&i.StatType,
			&i.TotalValue,
			&i.AvgValuePerGame,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPlayersByStat = `-- name: GetTopPlayersByStat :many
SELECT 
  p.player_id,
  p.full_name,
  p.position,
  SUM(s.stat_value) as total_value
FROM 
  nfl_stats s
JOIN 
  nfl_players p ON s.player_id = p.player_id
JOIN 
  nfl_games g ON s.game_id = g.event_id
WHERE 
  s.stat_type = ? AND g.season = ?
GROUP BY 
  p.player_id, p.full_name, p.position
ORDER BY 
  total_value DESC
LIMIT ?
`

type GetTopPlayersByStatParams struct {
	StatType string `json:"stat_type"`
	Season   int64  `json:"season"`
	Limit    int64  `json:"limit"`
}

type GetTopPlayersByStatRow struct {
	PlayerID   string          `json:"player_id"`
	FullName   string          `json:"full_name"`
	Position   string          `json:"position"`
	TotalValue sql.NullFloat64 `json:"total_value"`
}

// Get top N players for a specific stat type in a season
func (q *Queries) GetTopPlayersByStat(ctx context.Context, arg GetTopPlayersByStatParams) ([]*GetTopPlayersByStatRow, error) {
	rows, err := q.query(ctx, q.getTopPlayersByStatStmt, getTopPlayersByStat, arg.StatType, arg.Season, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTopPlayersByStatRow{}
	for rows.Next() {
		var i GetTopPlayersByStatRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.FullName,
			&i.Position,
			&i.TotalValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNFLStat = `-- name: UpdateNFLStat :exec
UPDATE nfl_stats
SET stat_value = ?
WHERE stat_id = ?
`

type UpdateNFLStatParams struct {
	StatValue float64 `json:"stat_value"`
	StatID    int64   `json:"stat_id"`
}

func (q *Queries) UpdateNFLStat(ctx context.Context, arg UpdateNFLStatParams) error {
	_, err := q.exec(ctx, q.updateNFLStatStmt, updateNFLStat, arg.StatValue, arg.StatID)
	return err
}

const upsertNFLStat = `-- name: UpsertNFLStat :exec
INSERT INTO nfl_stats (
  game_id, player_id, team_id, category, stat_type, stat_value
) VALUES (
  ?, ?, ?, ?, ?, ?
) ON CONFLICT(game_id, player_id, team_id, category, stat_type) DO UPDATE SET
  stat_value = excluded.stat_value
`

type UpsertNFLStatParams struct {
	GameID    int64   `json:"game_id"`
	PlayerID  string  `json:"player_id"`
	TeamID    string  `json:"team_id"`
	Category  string  `json:"category"`
	StatType  string  `json:"stat_type"`
	StatValue float64 `json:"stat_value"`
}

func (q *Queries) UpsertNFLStat(ctx context.Context, arg UpsertNFLStatParams) error {
	_, err := q.exec(ctx, q.upsertNFLStatStmt, upsertNFLStat,
		arg.GameID,
		arg.PlayerID,
		arg.TeamID,
		arg.Category,
		arg.StatType,
		arg.StatValue,
	)
	return err
}
