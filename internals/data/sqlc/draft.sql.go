// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: draft.sql

package data

import (
	"context"
	"database/sql"
)

const addDraftPick = `-- name: AddDraftPick :one
INSERT INTO fantasy_drafts (
    league_id,
    team_id,
    player_id,
    round,
    pick_number,
    draft_time
) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
RETURNING id
`

type AddDraftPickParams struct {
	LeagueID   int64 `json:"league_id"`
	TeamID     int64 `json:"team_id"`
	PlayerID   int64 `json:"player_id"`
	Round      int64 `json:"round"`
	PickNumber int64 `json:"pick_number"`
}

func (q *Queries) AddDraftPick(ctx context.Context, arg AddDraftPickParams) (int64, error) {
	row := q.queryRow(ctx, q.addDraftPickStmt, addDraftPick,
		arg.LeagueID,
		arg.TeamID,
		arg.PlayerID,
		arg.Round,
		arg.PickNumber,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const clearDraft = `-- name: ClearDraft :exec
DELETE FROM fantasy_drafts
WHERE league_id = ?
`

func (q *Queries) ClearDraft(ctx context.Context, leagueID int64) error {
	_, err := q.exec(ctx, q.clearDraftStmt, clearDraft, leagueID)
	return err
}

const getAllPlayersWithFantasyPoints = `-- name: GetAllPlayersWithFantasyPoints :many
SELECT 
    p.id,
    p.name,
    p.position,
    t.name as team_name,
    t.abbreviation as team_abbreviation,
    COALESCE(
        (SELECT SUM(fps.points) 
         FROM fantasy_player_scores fps 
         WHERE fps.player_id = p.id AND fps.league_id = ?1 AND fps.season_id = ?2), 
        0
    ) as previous_season_points,
    COALESCE(
        (SELECT AVG(fps.points) 
         FROM fantasy_player_scores fps 
         WHERE fps.player_id = p.id AND fps.league_id = ?1 AND fps.season_id = ?2 AND fps.points > 0), 
        0
    ) as avg_points_per_game,
    COALESCE(
        (SELECT COUNT(fps.week) 
         FROM fantasy_player_scores fps 
         WHERE fps.player_id = p.id AND fps.league_id = ?1 AND fps.season_id = ?2 AND fps.points > 0), 
        0
    ) as games_with_points
FROM nfl_players p
LEFT JOIN nfl_teams t ON p.team_id = t.id
WHERE p.position = ?3
ORDER BY previous_season_points DESC, avg_points_per_game DESC
LIMIT ?4
`

type GetAllPlayersWithFantasyPointsParams struct {
	LeagueID int64  `json:"league_id"`
	SeasonID int64  `json:"season_id"`
	Position string `json:"position"`
	Limit    int64  `json:"limit"`
}

type GetAllPlayersWithFantasyPointsRow struct {
	ID                   int64          `json:"id"`
	Name                 string         `json:"name"`
	Position             string         `json:"position"`
	TeamName             sql.NullString `json:"team_name"`
	TeamAbbreviation     sql.NullString `json:"team_abbreviation"`
	PreviousSeasonPoints interface{}    `json:"previous_season_points"`
	AvgPointsPerGame     interface{}    `json:"avg_points_per_game"`
	GamesWithPoints      interface{}    `json:"games_with_points"`
}

func (q *Queries) GetAllPlayersWithFantasyPoints(ctx context.Context, arg GetAllPlayersWithFantasyPointsParams) ([]*GetAllPlayersWithFantasyPointsRow, error) {
	rows, err := q.query(ctx, q.getAllPlayersWithFantasyPointsStmt, getAllPlayersWithFantasyPoints,
		arg.LeagueID,
		arg.SeasonID,
		arg.Position,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllPlayersWithFantasyPointsRow{}
	for rows.Next() {
		var i GetAllPlayersWithFantasyPointsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.TeamName,
			&i.TeamAbbreviation,
			&i.PreviousSeasonPoints,
			&i.AvgPointsPerGame,
			&i.GamesWithPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableDraftPlayers = `-- name: GetAvailableDraftPlayers :many
SELECT 
    p.id,
    p.name,
    p.position,
    t.abbreviation as team_abbreviation,
    COALESCE(
        (SELECT SUM(fps.points) 
         FROM fantasy_player_scores fps 
         WHERE fps.player_id = p.id AND fps.league_id = ?1 AND fps.season_id = ?2), 
        0
    ) as previous_season_points,
    COALESCE(
        (SELECT AVG(fps.points) 
         FROM fantasy_player_scores fps 
         WHERE fps.player_id = p.id AND fps.league_id = ?1 AND fps.season_id = ?2), 
        0
    ) as avg_points_per_game
FROM nfl_players p
LEFT JOIN nfl_teams t ON p.team_id = t.id
WHERE p.id NOT IN (
    SELECT player_id FROM fantasy_drafts WHERE league_id = ?1
)
AND p.position = ?3
ORDER BY previous_season_points DESC
LIMIT ?4
`

type GetAvailableDraftPlayersParams struct {
	LeagueID int64  `json:"league_id"`
	SeasonID int64  `json:"season_id"`
	Position string `json:"position"`
	Limit    int64  `json:"limit"`
}

type GetAvailableDraftPlayersRow struct {
	ID                   int64          `json:"id"`
	Name                 string         `json:"name"`
	Position             string         `json:"position"`
	TeamAbbreviation     sql.NullString `json:"team_abbreviation"`
	PreviousSeasonPoints interface{}    `json:"previous_season_points"`
	AvgPointsPerGame     interface{}    `json:"avg_points_per_game"`
}

func (q *Queries) GetAvailableDraftPlayers(ctx context.Context, arg GetAvailableDraftPlayersParams) ([]*GetAvailableDraftPlayersRow, error) {
	rows, err := q.query(ctx, q.getAvailableDraftPlayersStmt, getAvailableDraftPlayers,
		arg.LeagueID,
		arg.SeasonID,
		arg.Position,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAvailableDraftPlayersRow{}
	for rows.Next() {
		var i GetAvailableDraftPlayersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.TeamAbbreviation,
			&i.PreviousSeasonPoints,
			&i.AvgPointsPerGame,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestAvailablePlayers = `-- name: GetBestAvailablePlayers :many
SELECT 
    p.id,
    p.name,
    p.position,
    t.abbreviation as team_abbreviation,
    COALESCE(
        (SELECT SUM(fps.points) 
         FROM fantasy_player_scores fps 
         WHERE fps.player_id = p.id AND fps.league_id = ?1 AND fps.season_id = ?2), 
        0
    ) as previous_season_points
FROM nfl_players p
LEFT JOIN nfl_teams t ON p.team_id = t.id
WHERE p.id NOT IN (
    SELECT player_id FROM fantasy_drafts WHERE league_id = ?1
)
AND p.position = ?3
ORDER BY p.position, previous_season_points DESC
LIMIT ?4
`

type GetBestAvailablePlayersParams struct {
	LeagueID int64  `json:"league_id"`
	SeasonID int64  `json:"season_id"`
	Position string `json:"position"`
	Limit    int64  `json:"limit"`
}

type GetBestAvailablePlayersRow struct {
	ID                   int64          `json:"id"`
	Name                 string         `json:"name"`
	Position             string         `json:"position"`
	TeamAbbreviation     sql.NullString `json:"team_abbreviation"`
	PreviousSeasonPoints interface{}    `json:"previous_season_points"`
}

func (q *Queries) GetBestAvailablePlayers(ctx context.Context, arg GetBestAvailablePlayersParams) ([]*GetBestAvailablePlayersRow, error) {
	rows, err := q.query(ctx, q.getBestAvailablePlayersStmt, getBestAvailablePlayers,
		arg.LeagueID,
		arg.SeasonID,
		arg.Position,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBestAvailablePlayersRow{}
	for rows.Next() {
		var i GetBestAvailablePlayersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.TeamAbbreviation,
			&i.PreviousSeasonPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDraftOrder = `-- name: GetDraftOrder :many
SELECT
    ft.id as team_id,
    ft.name as team_name,
    ft.owner_name,
    ft.draft_position
FROM fantasy_teams ft
WHERE ft.league_id = ?
ORDER BY ft.draft_position
`

type GetDraftOrderRow struct {
	TeamID        int64         `json:"team_id"`
	TeamName      string        `json:"team_name"`
	OwnerName     string        `json:"owner_name"`
	DraftPosition sql.NullInt64 `json:"draft_position"`
}

func (q *Queries) GetDraftOrder(ctx context.Context, leagueID int64) ([]*GetDraftOrderRow, error) {
	rows, err := q.query(ctx, q.getDraftOrderStmt, getDraftOrder, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetDraftOrderRow{}
	for rows.Next() {
		var i GetDraftOrderRow
		if err := rows.Scan(
			&i.TeamID,
			&i.TeamName,
			&i.OwnerName,
			&i.DraftPosition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDraftPicksByTeam = `-- name: GetDraftPicksByTeam :many
SELECT 
    fd.id,
    fd.league_id,
    fd.team_id,
    fd.player_id,
    p.name as player_name,
    p.position as player_position,
    t.abbreviation as team_abbreviation,
    fd.round,
    fd.pick_number,
    fd.draft_time
FROM fantasy_drafts fd
JOIN nfl_players p ON fd.player_id = p.id
LEFT JOIN nfl_teams t ON p.team_id = t.id
WHERE fd.league_id = ? AND fd.team_id = ?
ORDER BY fd.pick_number
`

type GetDraftPicksByTeamParams struct {
	LeagueID int64 `json:"league_id"`
	TeamID   int64 `json:"team_id"`
}

type GetDraftPicksByTeamRow struct {
	ID               int64          `json:"id"`
	LeagueID         int64          `json:"league_id"`
	TeamID           int64          `json:"team_id"`
	PlayerID         int64          `json:"player_id"`
	PlayerName       string         `json:"player_name"`
	PlayerPosition   string         `json:"player_position"`
	TeamAbbreviation sql.NullString `json:"team_abbreviation"`
	Round            int64          `json:"round"`
	PickNumber       int64          `json:"pick_number"`
	DraftTime        sql.NullString `json:"draft_time"`
}

func (q *Queries) GetDraftPicksByTeam(ctx context.Context, arg GetDraftPicksByTeamParams) ([]*GetDraftPicksByTeamRow, error) {
	rows, err := q.query(ctx, q.getDraftPicksByTeamStmt, getDraftPicksByTeam, arg.LeagueID, arg.TeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetDraftPicksByTeamRow{}
	for rows.Next() {
		var i GetDraftPicksByTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.LeagueID,
			&i.TeamID,
			&i.PlayerID,
			&i.PlayerName,
			&i.PlayerPosition,
			&i.TeamAbbreviation,
			&i.Round,
			&i.PickNumber,
			&i.DraftTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDraftPicksForLeague = `-- name: GetDraftPicksForLeague :many
SELECT 
    fd.id,
    fd.league_id,
    fd.team_id,
    ft.name as team_name,
    fd.player_id,
    p.name as player_name,
    p.position as player_position,
    t.abbreviation as team_abbreviation,
    fd.round,
    fd.pick_number,
    fd.draft_time
FROM fantasy_drafts fd
JOIN fantasy_teams ft ON fd.team_id = ft.id
JOIN nfl_players p ON fd.player_id = p.id
LEFT JOIN nfl_teams t ON p.team_id = t.id
WHERE fd.league_id = ?
ORDER BY fd.pick_number
`

type GetDraftPicksForLeagueRow struct {
	ID               int64          `json:"id"`
	LeagueID         int64          `json:"league_id"`
	TeamID           int64          `json:"team_id"`
	TeamName         string         `json:"team_name"`
	PlayerID         int64          `json:"player_id"`
	PlayerName       string         `json:"player_name"`
	PlayerPosition   string         `json:"player_position"`
	TeamAbbreviation sql.NullString `json:"team_abbreviation"`
	Round            int64          `json:"round"`
	PickNumber       int64          `json:"pick_number"`
	DraftTime        sql.NullString `json:"draft_time"`
}

func (q *Queries) GetDraftPicksForLeague(ctx context.Context, leagueID int64) ([]*GetDraftPicksForLeagueRow, error) {
	rows, err := q.query(ctx, q.getDraftPicksForLeagueStmt, getDraftPicksForLeague, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetDraftPicksForLeagueRow{}
	for rows.Next() {
		var i GetDraftPicksForLeagueRow
		if err := rows.Scan(
			&i.ID,
			&i.LeagueID,
			&i.TeamID,
			&i.TeamName,
			&i.PlayerID,
			&i.PlayerName,
			&i.PlayerPosition,
			&i.TeamAbbreviation,
			&i.Round,
			&i.PickNumber,
			&i.DraftTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDraftSummary = `-- name: GetDraftSummary :many
SELECT 
    p.position,
    COUNT(*) as players_drafted
FROM fantasy_drafts fd
JOIN nfl_players p ON fd.player_id = p.id
WHERE fd.league_id = ? AND fd.team_id = ?
GROUP BY p.position
ORDER BY p.position
`

type GetDraftSummaryParams struct {
	LeagueID int64 `json:"league_id"`
	TeamID   int64 `json:"team_id"`
}

type GetDraftSummaryRow struct {
	Position       string `json:"position"`
	PlayersDrafted int64  `json:"players_drafted"`
}

func (q *Queries) GetDraftSummary(ctx context.Context, arg GetDraftSummaryParams) ([]*GetDraftSummaryRow, error) {
	rows, err := q.query(ctx, q.getDraftSummaryStmt, getDraftSummary, arg.LeagueID, arg.TeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetDraftSummaryRow{}
	for rows.Next() {
		var i GetDraftSummaryRow
		if err := rows.Scan(&i.Position, &i.PlayersDrafted); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastDraftPick = `-- name: GetLastDraftPick :one
SELECT 
    MAX(pick_number) as last_pick_number,
    (MAX(pick_number) / teams_count) as last_completed_round
FROM fantasy_drafts fd
JOIN fantasy_leagues fl ON fd.league_id = fl.id
WHERE fd.league_id = ?
`

type GetLastDraftPickRow struct {
	LastPickNumber     interface{} `json:"last_pick_number"`
	LastCompletedRound interface{} `json:"last_completed_round"`
}

func (q *Queries) GetLastDraftPick(ctx context.Context, leagueID int64) (*GetLastDraftPickRow, error) {
	row := q.queryRow(ctx, q.getLastDraftPickStmt, getLastDraftPick, leagueID)
	var i GetLastDraftPickRow
	err := row.Scan(&i.LastPickNumber, &i.LastCompletedRound)
	return &i, err
}

const getNextDraftingTeam = `-- name: GetNextDraftingTeam :one
WITH league_info AS (
    SELECT 
        fl.id,
        fl.teams_count,
        COUNT(fd.id) as picks_made
    FROM fantasy_leagues fl
    LEFT JOIN fantasy_drafts fd ON fl.id = fd.league_id
    WHERE fl.id = ?
    GROUP BY fl.id, fl.teams_count
),
draft_position AS (
    SELECT
        li.picks_made + 1 as next_pick_number,
        CEIL((li.picks_made + 1) * 1.0 / li.teams_count) as next_round,
        MOD(li.picks_made, li.teams_count) + 1 as position_in_round
    FROM league_info li
),
snake_position AS (
    SELECT
        dp.next_pick_number,
        dp.next_round,
        CASE 
            WHEN dp.next_round % 2 = 1 THEN dp.position_in_round
            ELSE li.teams_count - dp.position_in_round + 1
        END as snake_draft_position
    FROM draft_position dp, league_info li
)
SELECT
    ft.id,
    ft.name,
    ft.owner_name,
    ft.is_user,
    sp.next_pick_number as pick_number,
    sp.next_round as round
FROM snake_position sp
JOIN fantasy_teams ft ON ft.draft_position = sp.snake_draft_position
WHERE ft.league_id = ?
`

type GetNextDraftingTeamParams struct {
	ID       int64 `json:"id"`
	LeagueID int64 `json:"league_id"`
}

type GetNextDraftingTeamRow struct {
	ID         int64         `json:"id"`
	Name       string        `json:"name"`
	OwnerName  string        `json:"owner_name"`
	IsUser     sql.NullInt64 `json:"is_user"`
	PickNumber int64         `json:"pick_number"`
	Round      int64         `json:"round"`
}

func (q *Queries) GetNextDraftingTeam(ctx context.Context, arg GetNextDraftingTeamParams) (*GetNextDraftingTeamRow, error) {
	row := q.queryRow(ctx, q.getNextDraftingTeamStmt, getNextDraftingTeam, arg.ID, arg.LeagueID)
	var i GetNextDraftingTeamRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerName,
		&i.IsUser,
		&i.PickNumber,
		&i.Round,
	)
	return &i, err
}

const getTeamAtDraftPosition = `-- name: GetTeamAtDraftPosition :one
SELECT 
    id,
    name,
    owner_name,
    is_user
FROM fantasy_teams
WHERE league_id = ? AND draft_position = ?
`

type GetTeamAtDraftPositionParams struct {
	LeagueID      int64         `json:"league_id"`
	DraftPosition sql.NullInt64 `json:"draft_position"`
}

type GetTeamAtDraftPositionRow struct {
	ID        int64         `json:"id"`
	Name      string        `json:"name"`
	OwnerName string        `json:"owner_name"`
	IsUser    sql.NullInt64 `json:"is_user"`
}

func (q *Queries) GetTeamAtDraftPosition(ctx context.Context, arg GetTeamAtDraftPositionParams) (*GetTeamAtDraftPositionRow, error) {
	row := q.queryRow(ctx, q.getTeamAtDraftPositionStmt, getTeamAtDraftPosition, arg.LeagueID, arg.DraftPosition)
	var i GetTeamAtDraftPositionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerName,
		&i.IsUser,
	)
	return &i, err
}
